import { Injectable } from '@nestjs/common';
import * as fs from 'fs/promises';
import * as path from 'path';
import { BEETS_LIBRARY_ROOT, SYNCTHING_STIGNORE_FILE_NAME } from 'src/env-vars';
import { TrackService } from 'src/track/track.service';

const STIGNORE_FILE_PATH = path.join(BEETS_LIBRARY_ROOT, SYNCTHING_STIGNORE_FILE_NAME);

// Example of a line :
// !/path/to/file.mp3 #:123
const STIGNORE_BEET_ITEM_LINE_FORMAT: RegExp = /^!(.+) #:(\d+)$/;

@Injectable()
export class SyncthingService {
  private lastUpdate = 0;
  private data: number[] = null;

  constructor(private trackService: TrackService) { }

  async readSyncthingFile(): Promise<number[]> {
    if (!this.data || this.isDataOutdated()) {
      try {
        console.info(`Reading the Syncthing file ${STIGNORE_FILE_PATH}...`)

        this.data = await fs.readFile(STIGNORE_FILE_PATH)
          .toString()
          .split('\n')
          .map(line => line.match(STIGNORE_BEET_ITEM_LINE_FORMAT))
          .filter(line => Array.isArray(line) && line[1] && Number.isInteger(line[2]))
          .map(([, , id]) => Number.parseInt(id));

        console.info(`Loaded ${this.data.length} ids from the Syncthing file.`);

      } catch (e) {
        console.warn(`Couldn't read the Syncthing file!`);
        this.data = [];
      }
    }

    return this.data;
  }

  unescapeSyncthingIgnorePath(escapedPath: string): string {
    return escapedPath;
  }

  escapeSyncthingPath(path: Buffer | string): string {
    return path.toString();
  }

  async writeSyncthingFile(ids: number[]) {
    const data = await this.trackService.getPathsOfIds(ids)

    try {
      await fs.writeFile(STIGNORE_FILE_PATH, [
        '### AUTOGENERATED FILE - DO NOT EDIT ###',
        '*',
        ...data.map(({ id, path }) =>
          `!${this.escapeSyncthingPath(path)} #:${id}`)
      ]);
    } catch (e) {
      console.error(`Couldn't write the Syncthing file with ${this.data.length} lines: `, e);
      throw e;
    }
  }

  private isDataOutdated(): boolean {
    const ONE_HOUR = 1000 * 60 * 60;
    const now = (new Date).getTime();
    const timeSinceLastUpdate = now - this.lastUpdate;

    return timeSinceLastUpdate > ONE_HOUR;
  }
}
